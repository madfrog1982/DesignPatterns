# 定义

>⒈类适配器模式：

>在新环境中不需要去重复实现已经存在了的实现而很好地把现有对象（指原来环境中的现有对象）加入到新环境来使用。把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作。

>⒉对象适配器模式

>既然现在适配器类不能继承TwoHole抽象类了(因为用继承就属于类的适配器了)，但是适配器类无论如何都要实现客户端期待的方法的，即Request方法，所以一定是要继承ThreeHole抽象类或IThreeHole接口的，然而适配器类的Request方法又必须调用TwoHole的SpecificRequest方法，又不能用继承，这时候就想，不能继承，但是我们可以在适配器类中创建TwoHole对象，然后在Requst中使用TwoHole的方法了。

# 类适配器模式优点与缺点

>**优点**：

>⒈可以在不修改原有代码的基础上来复用现有类，很好地符合“开闭原则”。

>⒉可以重新定义Adaptee(被适配的类)的部分行为，因为在类适配器模式中，Adapter是Adaptee的子类。

>⒊仅仅引入一个对象，并不需要额外的字段来引用Adaptee实例（这个即是优点也是缺点）。

>**缺点**：

>⒈用一个具体的Adapter类对Adaptee和Target进行匹配，当如果想要匹配一个类以及所有它的子类时，类的适配器模式就不能胜任了。因为类的适配器模式中没有引入Adaptee的实例，光调用this.SpecificRequest方法并不能去调用它对应子类的SpecificRequest方法。
    
>⒉采用了“多继承”的实现方式，带来了不良的高耦合。

# 对象适配器模式优点与缺点

>**优点**：

>⒈可以在不修改原有代码的基础上来复用现有类，很好地符合“开闭原则”（这点是两种实现方式都具有的）。

>⒉采用“对象组合”的方式，更符合松耦合。

>**缺点**：

>⒈使得重定义Adaptee的行为较困难，这就需要生成Adaptee的子类并且使得Adapter引用这个子类而不是引用Adaptee本身。

# 使用场景

>⒈系统需要复用现有类，而该类的接口不符合系统的需求。

>⒉想要建立一个可重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。

>⒊对于对象适配器模式，在设计里需要改变多个已有子类的接口，如果使用类的适配器模式，就要针对每一个子类做一个适配器，而这不太实际。